library(ggpubr)
library(dplyr)
ref_genome <- "BSgenome.Hsapiens.UCSC.hg38"
library(ref_genome, character.only = TRUE)
# Load functions and colour palettes
mycols_paired <- brewer.pal(12,"Paired")
mycols_dark2  <- brewer.pal(8, "Dark2")
source('~/hpc/pmc_vanboxtel/projects/CHemALL/2_Code/theme_CHemALL.R')
# Set directory
setwd("~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/")
# Load metadata
input_df       <- read_excel('~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/1_Input/Sample_overview.xlsx')
diagnostic_df  <- read.csv('~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/1_Input/Bulk_sample_overview.csv')
low_callable_df<- read.csv('~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/QC/Data/low_callable_loci.csv')
below_curve_df <- read.csv('~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/QC/Data/below_curve_samples.csv')
bad_baf_df     <- read.csv('~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/QC/Data/bad_baf_samples.csv')
fail_vaf_df    <- read.csv('~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/QC/Data/PTA_samples_failVAFcheck.txt')
# Make blacklist
blacklist <- unique(c(below_curve_df$Sample_name,
low_callable_df$Sample_name,
bad_baf_df$Sample_name,
fail_vaf_df$samplename))
# Load single cell VCF files (PTATO filtered)
ptato_dir <- "~/hpc/pmc_vanboxtel/projects/Burkitt/3_Output/PTATO"
folders_to_check <- c("P3G6", "PRN4", "P856", "PIA9", "PVA9", "PJBU")
all_filtered_vcfs <- unlist(lapply(folders_to_check, function(subdir) {
list.files(
file.path(ptato_dir, subdir),
pattern = "snvs.*filtered\\.vcf(\\.gz)?$",
recursive = TRUE,
full.names = TRUE
)
}))
# Remove old PTATO file names
all_filtered_vcfs <- all_filtered_vcfs[!grepl("old", all_filtered_vcfs, ignore.case = TRUE)]
# Samples re-run with PTAv2 filtering → drop earlier filtered files
samples_to_exclude <- c(
"PB11197-BLASC-BCELLP1B4","PB11197-BLASC-BCELLP1C4","PB11197-BLASC-BCELLP1I4",
"PB11197-BLASC-BCELLP1J3","PB11197-BLASC-BCELLP1K4","PB11197-BLASC-BCELLP1L3",
"PB11197-BLASC-BCELLP1O3","PB11197-BLASC-BCELLP1P3","P3G6GDDABC71",
"PB14458-BLPL-BCELLP4B3","PB14458-BLPL-BCELLP4B5","PB14458-BLPL-BCELLP4C3",
"PB14458-BLPL-BCELLP4D3","PB14458-BLPL-BCELLP4D5","PB14458-BLPL-BCELLP4E3",
"PB14458-BLPL-BCELLP4J3","PB14458-BLPL-BCELLP4K3","PB14458-BLPL-BCELLP4K5",
"PB14458-BLPL-BCELLP4L3","PB14458-BLPL-BCELLP4L5","PB14458-BLPL-BCELLP4M3",
"P856GDDUBC32","P856GDDUBC33","P856GDDUBC34","P856GDDUBC40","P856GDDUBC41",
"P856GDDUBC42","P856GDDUBC43","P856GDDUBC44","P856GDDUBC45",
"PB14458-BLBM-BCELLP2B3","PB14458-BLBM-BCELLP2B4","PB14458-BLBM-BCELLP2C4",
"PB14458-BLBM-BCELLP2E4","PB14458-BLBM-BCELLP2F2","PB14458-BLBM-BCELLP2F4",
"PB14458-BLBM-BCELLP2I2","PB14458-BLBM-BCELLP2L3","PB14458-BLBM-BCELLP2L4",
"PB14458-BLBM-BCELLP2M4","PB14458-BLBM-BCELLP2N2","PB14458-BLBM-BCELLP2N4",
"P856GDDBBC46","P856GDDBBC48","P856GDDBBC54","P856GDDBBC57","P856GDDBBC58",
"P856GDDBBC59","P856GDDBBC60","P856GDDBBC61","P856GDDBBC62","P856GDDBBC63","P856GDDBBC64"
)
pattern_exclude <- paste0("(", paste0(samples_to_exclude, collapse = "|"), ").*\\.snvs\\.ptato\\.filtered\\.vcf\\.gz$")
all_filtered_vcfs <- all_filtered_vcfs[!grepl(pattern_exclude, all_filtered_vcfs, ignore.case = TRUE)]
# Filter out blacklist samples
single_cell_sample_names <- sub(".*\\.vep_([^/\\.]+).*", "\\1", all_filtered_vcfs)
scWGS_vcf_files_sub      <- all_filtered_vcfs[!single_cell_sample_names %in% blacklist]
single_cell_sample_names_sub <- single_cell_sample_names[!single_cell_sample_names %in% blacklist]
# Create mutational matrix
my_grl <- read_vcfs_as_granges(scWGS_vcf_files_sub, single_cell_sample_names_sub, ref_genome, type = 'snv')
# Define autosomes
autosomes <- paste0("chr", 1:22)
# Keep only autosomes in the GRangesList
my_grl_autosomes <- endoapply(my_grl, function(x) x[seqnames(x) %in% autosomes])
mut_mat_internal <- mut_matrix(vcf_list = get_mut_type(my_grl_autosomes, 'snv'), ref_genome = ref_genome)
# Keep only non-Myc translocated
input_df_filtered <- input_df[input_df$ResolveDNA_version %in% c("v1", "v2.0", "v2") &
!input_df$Sample_name %in% blacklist, , drop = FALSE]
cols_to_keep <- input_df_filtered$Sample_name[input_df_filtered$Myc_translocation_IGV == "No"]
mut_mat_filtered <- mut_mat_internal[, cols_to_keep, drop = FALSE]
# Get signatures
all_signatures <- get_known_signatures()
sbsblood <- read.table("~/Downloads/sigfit_cosmic3_bloodsig_Aug2020.txt", sep = "\t", header = TRUE) |> as.matrix()
SBSblood <- as.numeric(sbsblood[, "Signature.Blood"])
signatures <- cbind(SBSblood, all_signatures)
# Refitting part with chosen signatures
required_cols <- c("SBS1","SBS7a", "SBS9", "SBS17b", "SBS18", "SBSblood")
sub_sig <- signatures[, required_cols]
fit_strict <- fit_to_signatures_strict(
mut_mat_filtered,
sub_sig,
max_delta = 0.002
)
fit_res <- fit_strict$fit_res$contribution
fit_res_df <- as.data.frame(t(fit_res)) %>%
tibble::rownames_to_column("sample")
df_t1 <- t(fit_res_df %>% column_to_rownames('sample'))
# Plot cosine similarity
plot_original_vs_reconstructed(mut_mat_filtered, fit_strict$fit_res$reconstructed,
y_intercept = 0.85, ylims = c(0,1))
# Quick plots
p1 <- plot_contribution(df_t1[, 1:63], coord_flip = FALSE, mode = "relative") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
p2 <- plot_contribution(df_t1[, 1:63], coord_flip = FALSE, mode = "absolute") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
# Group samples by SBS9 proportion
total <- colSums(df_t1)
sbs9_vals    <- df_t1["SBS9", ]
sbs9_prop    <- sbs9_vals / total
samples_sbs9pos <- names(sbs9_prop[sbs9_prop > 0])
samples_sbs9neg  <- names(sbs9_prop[sbs9_prop <= 0])
df_sbs9_status <- tibble(
Sample_name = c(samples_sbs9pos, samples_sbs9neg),
SBS9_status = c(
rep("Positive", length(samples_sbs9pos)),
rep("Negative", length(samples_sbs9neg))
)
)
# SNV load per sample and normalization by callable fraction
snv_load <- colSums(mut_mat_filtered)
callable_fraction <- setNames(input_df$Callable_fraction, input_df$Sample_name)
callable_fraction <- callable_fraction[names(snv_load)]
snv_load_normalized <- snv_load / callable_fraction
names(snv_load_normalized) <- names(snv_load)
# Build plot_df with groups
all_samples <- intersect(names(snv_load_normalized), names(sbs9_prop))
plot_df <- data.frame(
sample        = all_samples,
snv_load_norm = snv_load_normalized[all_samples],
group         = ifelse(all_samples %in% samples_sbs9pos, "SBS9-positive", "SBS9-negative"),
stringsAsFactors = FALSE
)
plot_df$group <- factor(plot_df$group, levels = c("SBS9-positive", "SBS9-negative"))
# Box plot + t-test p-value
p1_box <- ggplot(plot_df, aes(x = group, y = snv_load_norm, fill = group)) +
geom_boxplot(outlier.shape = NA, alpha = 0.6) +
labs(x = "", y = "SNV load (normalized to callable loci)", title = "SNV load in normal B-cells comparing SBS9-positive vs SBS9-negative") +
scale_y_continuous(limits = c(0, 3000)) +
scale_fill_manual(values = c("SBS9-positive" = "#e7872b", "SBS9-negative" = "#a0501a")) +
theme_minimal(base_size = 14) +
theme_CHemALL() +
theme(legend.position = "none",
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank()) +
stat_compare_means(method = "t.test", label = "p.format",
comparisons = list(c("SBS9-positive", "SBS9-negative")))
# Palette for signatures
pal <- c("#D2BD96","#6C5B78", "#0A9086", "#B3B3B3", "#A62639", "#1D3557")
names(pal) <- c("SBS1","SBS7a", "SBS9","SBS17b","SBS18","SBSblood")
# Correct per signature for callable fraction (skip for now)
#callable_fraction <- setNames(input_df$Callable_fraction, input_df$Sample_name)
#df_corrected <- sweep(df_t1, 2, callable_fraction[colnames(df_t1)], FUN = "/")
# Add metadata
ages <- setNames(input_df$Age_at_sampling_Y, input_df$Sample_name)
df_long <- as.data.frame(t(df_t1))
df_long$Sample <- rownames(df_long)
df_long$Age <- ages[df_long$Sample]
df_long$CellType <- ifelse(
input_df$Myc_translocation_IGV[match(df_long$Sample, input_df$Sample_name)] == "No",
"WT cells", "Malignant cells"
)
# Long format
df_melt <- melt(df_long, id.vars = c("Sample", "Age", "CellType"),
variable.name = "Signature", value.name = "SNV_per_genome")
df_melt_clean <- df_melt %>%
na.omit() %>%
mutate(Age = as.numeric(Age)) %>%
filter(is.finite(SNV_per_genome), is.finite(Age))
# Plot age vs SNVs per genome (WT only), faceted by signature
p_age <- ggplot(df_melt_clean %>% filter(CellType == "WT cells"),
aes(x = Age, y = SNV_per_genome, colour = Signature)) +
geom_jitter(alpha = 0.8, width = 0.5, height = 0.5) +
scale_colour_manual(values = pal) +
xlab("Age") + ylab("SNVs / genome") +
geom_smooth(method = "lm", se = FALSE, lwd = 0.4) +
facet_wrap(~Signature, scales = "free_y", nrow = 2) +
theme_bw() +
theme(axis.title = element_text(size = 10),
axis.text = element_text(size = 8),
strip.background = element_rect(fill = "white", color = "white"),
strip.text = element_text(colour = 'black', size = 10, face = "plain", hjust = 0),
legend.position = "none",
legend.text = element_text(size = 8),
legend.key.size = unit(0.35, 'cm'),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
# Total [C>T]G across 4 contexts (WT only), normalized by callable fraction
ctg_motifs <- c("A[C>T]G", "C[C>T]G", "G[C>T]G", "T[C>T]G")
stopifnot(all(ctg_motifs %in% rownames(mut_mat_filtered)))
ctg_counts_total <- colSums(mut_mat_filtered[ctg_motifs, , drop = FALSE])
samples    <- names(ctg_counts_total)
callable_fraction <- setNames(input_df$Callable_fraction,    input_df$Sample_name)
ages              <- setNames(input_df$Age_at_sampling_Y,    input_df$Sample_name)
myc_status        <- setNames(input_df$Myc_translocation_IGV, input_df$Sample_name)
df_ctg <- data.frame(
Sample         = samples,
Age            = as.numeric(ages[samples]),
CellType       = ifelse(myc_status[samples] == "No", "WT cells", "Malignant cells"),
CTG_per_genome = as.numeric(ctg_counts_total / callable_fraction[samples]),
stringsAsFactors = FALSE
) %>%
filter(CellType == "WT cells") %>%
filter(is.finite(Age), is.finite(CTG_per_genome))
# Plot [C>T]G vs age (WT)
p_ctg <- ggplot(df_ctg, aes(x = Age, y = CTG_per_genome)) +
geom_jitter(alpha = 0.8, width = 0.4, height = 0.4, color = "#1D3557") +
geom_smooth(method = "lm", se = FALSE, lwd = 0.6, color = "#1D3557") +
coord_cartesian(ylim = c(0, 300)) +
xlab("Age") + ylab("Total [C>T]G per callable genome") +
theme_bw() +
theme(axis.title = element_text(size = 10),
axis.text  = element_text(size = 8),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
# Build faceted dataset (WT signatures + [C>T]G_total)
df_ctg_long <- df_ctg %>%
transmute(Sample, Age, CellType, Signature = "[C>T]G_total", SNV_per_genome = CTG_per_genome)
df_plot <- bind_rows(
df_melt_clean %>% filter(CellType == "WT cells"),
df_ctg_long
)
pal_plus <- c(pal, "[C>T]G_total" = "#444444")
# Faceted plot with free_y, but clamp [C>T]G_total to 0–300
# We add an invisible layer (geom_blank) ONLY for the "[C>T]G_total" facet to
# force its limits to [0, 300], while keeping the others free.
.blank_age <- suppressWarnings(min(df_plot$Age, na.rm = TRUE))
blank_df <- data.frame(
Age = rep(.blank_age, 2),
SNV_per_genome = c(0, 300),
Signature = "[C>T]G_total"
)
plot <- ggplot(df_plot, aes(x = Age, y = SNV_per_genome, colour = Signature)) +
# Invisible bounds for the [C>T]G_total facet
geom_blank(data = blank_df, inherit.aes = FALSE,
aes(x = Age, y = SNV_per_genome)) +
geom_jitter(alpha = 0.8, width = 0.4, height = 0.4) +
geom_smooth(method = "lm", se = FALSE, lwd = 0.4) +
scale_colour_manual(values = pal_plus) +
facet_wrap(~ Signature, scales = "free_y", nrow = 1) +
scale_x_continuous(limits = c(0, 20), breaks = seq(0, 20, by = 4)) +
xlab("Age") + ylab("SNVs / genome") +
theme_bw() +
theme(axis.title = element_text(size = 10),
axis.text  = element_text(size = 6),
strip.background = element_rect(fill = "white", color = "white"),
strip.text = element_text(color = "black", size = 6, hjust = 0.5),
legend.position = "none",
panel.grid.major = element_blank(),
panel.grid.minor = element_blank())
# Regression stats (WT-only data used in df_plot)
# Runs a linear regression for each signature, predicting mutation burden (SNV_per_genome) as a function of Age
my_sigs <- unique(df_plot$Signature)
regression_stats <- lapply(my_sigs, function(sig) {
fit <- lm(SNV_per_genome ~ Age, data = filter(df_plot, Signature == sig))
fit_sum <- summary(fit)
tibble(
Signature = sig,
beta      = fit_sum$coefficients[2, 1],
intercept = fit_sum$coefficients[1, 1],
p_value   = fit_sum$coefficients[2, 4],
R2        = fit_sum$r.squared,
RSE       = fit_sum$sigma
)
}) %>% bind_rows()
print(regression_stats)
plot
View(df_plot)
df_plot
df_grouped = (
df_plot.groupby(["Age", "Signature"], as_index=False)["SNV_per_genome"]
df_grouped = (
df_plot.groupby(["Age", "Signature"], as_index=False)["SNV_per_genome"]
df_relative <- df_plot %>%
group_by(Age, Signature) %>%
summarise(total_SNV = sum(SNV_per_genome, na.rm = TRUE)) %>%
group_by(Age) %>%
mutate(
relative_contribution = total_SNV / sum(total_SNV),
percent_contribution = relative_contribution * 100
) %>%
ungroup()
df_relative
View(df_relative)
df_relative <- df_plot %>%
filter(Signature != "[C>T]G_total") %>%
group_by(Age, Signature) %>%
summarise(total_SNV = sum(SNV_per_genome, na.rm = TRUE)) %>%
group_by(Age) %>%
mutate(
relative_contribution = total_SNV / sum(total_SNV),
percent_contribution = relative_contribution * 100
) %>%
ungroup()
df_relative
View(df_relative)
df_SBS18 <- df_relative %>%
filter(Signature == "SBS18")
View(df_SBS18)
library(shiny); runApp('~/surfdrive/Shared/pmc_vanboxtel/general/4_Data_stewardship/shiny/app_fixbyLucca.R')
################################################################################
# Manuscript: Clonal Evolution of Paediatric Burkitt Lymphoma Through Time and Space
# Description: Script to get filtered SNVs (total + autosomal) from single cell WGS samples
# Author: Alexander Steemers
# Date: June 2025
################################################################################
# Load libraries
library(reshape2)
library(ggplot2)
library(tidyverse)
library(VariantAnnotation)
library(readxl)
library(BSgenome)
library(GenomicRanges)
ref_genome <- "BSgenome.Hsapiens.UCSC.hg38"
library(ref_genome, character.only = TRUE)
library(MutationalPatterns)
# Set working directory
setwd("~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/MutLoad")
# Load functions and plotting functions
source('~/hpc/pmc_vanboxtel/projects/CHemALL/2_Code/PTATO/GeneralFunctions.R')
source('~/hpc/pmc_vanboxtel/projects/CHemALL/2_Code/theme_CHemALL.R')
# Load metadata
input_df <-  read_excel('~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/1_Input/Sample_overview.xlsx')
input_df_sc <- input_df[input_df$ResolveDNA_version %in% c("v1", "v2", "v2.0"), ]
input_df_sub <- input_df_sc[!is.na(input_df_sc$Callable_fraction) & !is.na(input_df_sc$Mean_coverage),]
# Define PTATO directory
ptato_dir <- "~/hpc/pmc_vanboxtel/projects/Burkitt/3_Output/PTATO"
# Which patients to check
folders_to_check <- c("P3G6", "PRN4", "P856", "PIA9", "PVA9", "PJBU")
# List all snv unfiltered and filtered VCF files
#all_unfiltered_vcfs <- unlist(lapply(folders_to_check, function(subdir) {
#  list.files(
#    file.path(ptato_dir, subdir),
#    pattern = "snvs\\.ptato\\.vcf(\\.gz)?$",
#    recursive = TRUE,
#    full.names = TRUE
#  )
#}))
all_filtered_vcfs <- unlist(lapply(folders_to_check, function(subdir) {
list.files(
file.path(ptato_dir, subdir),
pattern = "snvs.*filtered\\.vcf(\\.gz)?$",
recursive = TRUE,
full.names = TRUE
)
}))
# Remove old PTATO vcf file names
#all_unfiltered_vcfs <- all_unfiltered_vcfs[!grepl("old", all_unfiltered_vcfs, ignore.case = TRUE)]
all_filtered_vcfs <- all_filtered_vcfs[!grepl("old", all_filtered_vcfs, ignore.case = TRUE)]
all_filtered_vcfs
samples_to_exclude <- c(
# Original list
"PB11197-BLASC-BCELLP1B4",
"PB11197-BLASC-BCELLP1C4",
"PB11197-BLASC-BCELLP1I4",
"PB11197-BLASC-BCELLP1J3",
"PB11197-BLASC-BCELLP1K4",
"PB11197-BLASC-BCELLP1L3",
"PB11197-BLASC-BCELLP1O3",
"PB11197-BLASC-BCELLP1P3",
"P3G6GDDABC71",
"PB14458-BLPL-BCELLP4B3",
"PB14458-BLPL-BCELLP4B5",
"PB14458-BLPL-BCELLP4C3",
"PB14458-BLPL-BCELLP4D3",
"PB14458-BLPL-BCELLP4D5",
"PB14458-BLPL-BCELLP4E3",
"PB14458-BLPL-BCELLP4J3",
"PB14458-BLPL-BCELLP4K3",
"PB14458-BLPL-BCELLP4K5",
"PB14458-BLPL-BCELLP4L3",
"PB14458-BLPL-BCELLP4L5",
"PB14458-BLPL-BCELLP4M3",
"P856GDDUBC32",
"P856GDDUBC33",
"P856GDDUBC34",
"P856GDDUBC40",
"P856GDDUBC41",
"P856GDDUBC42",
"P856GDDUBC43",
"P856GDDUBC44",
"P856GDDUBC45",
"PB14458-BLBM-BCELLP2B3",
"PB14458-BLBM-BCELLP2B4",
"PB14458-BLBM-BCELLP2C4",
"PB14458-BLBM-BCELLP2E4",
"PB14458-BLBM-BCELLP2F2",
"PB14458-BLBM-BCELLP2F4",
"PB14458-BLBM-BCELLP2I2",
"PB14458-BLBM-BCELLP2L3",
"PB14458-BLBM-BCELLP2L4",
"PB14458-BLBM-BCELLP2M4",
"PB14458-BLBM-BCELLP2N2",
"PB14458-BLBM-BCELLP2N4",
"P856GDDBBC46",
"P856GDDBBC48",
"P856GDDBBC54",
"P856GDDBBC57",
"P856GDDBBC58",
"P856GDDBBC59",
"P856GDDBBC60",
"P856GDDBBC61",
"P856GDDBBC62",
"P856GDDBBC63",
"P856GDDBBC64"
)
samples_to_exclude
samples_to_exclude <- c(
# Original list
"PB11197-BLASC-BCELLP1B4",
"PB11197-BLASC-BCELLP1C4",
"PB11197-BLASC-BCELLP1I4",
"PB11197-BLASC-BCELLP1J3",
"PB11197-BLASC-BCELLP1K4",
"PB11197-BLASC-BCELLP1L3",
"PB11197-BLASC-BCELLP1O3",
"PB11197-BLASC-BCELLP1P3",
"P3G6GDDABC71",
"PB14458-BLPL-BCELLP4B3",
"PB14458-BLPL-BCELLP4B5",
"PB14458-BLPL-BCELLP4C3",
"PB14458-BLPL-BCELLP4D3",
"PB14458-BLPL-BCELLP4D5",
"PB14458-BLPL-BCELLP4E3",
"PB14458-BLPL-BCELLP4J3",
"PB14458-BLPL-BCELLP4K3",
"PB14458-BLPL-BCELLP4K5",
"PB14458-BLPL-BCELLP4L3",
"PB14458-BLPL-BCELLP4L5",
"PB14458-BLPL-BCELLP4M3",
"P856GDDUBC32",
"P856GDDUBC33",
"P856GDDUBC34",
"P856GDDUBC40",
"P856GDDUBC41",
"P856GDDUBC42",
"P856GDDUBC43",
"P856GDDUBC44",
"P856GDDUBC45",
"PB14458-BLBM-BCELLP2B3",
"PB14458-BLBM-BCELLP2B4",
"PB14458-BLBM-BCELLP2C4",
"PB14458-BLBM-BCELLP2E4",
"PB14458-BLBM-BCELLP2F2",
"PB14458-BLBM-BCELLP2F4",
"PB14458-BLBM-BCELLP2I2",
"PB14458-BLBM-BCELLP2L3",
"PB14458-BLBM-BCELLP2L4",
"PB14458-BLBM-BCELLP2M4",
"PB14458-BLBM-BCELLP2N2",
"PB14458-BLBM-BCELLP2N4",
"P856GDDBBC46",
"P856GDDBBC48",
"P856GDDBBC54",
"P856GDDBBC57",
"P856GDDBBC58",
"P856GDDBBC59",
"P856GDDBBC60",
"P856GDDBBC61",
"P856GDDBBC62",
"P856GDDBBC63",
"P856GDDBBC64"
)
pattern_exclude <- paste0(samples_to_exclude, collapse = "|")
pattern_exclude <- paste0("(", pattern_exclude, ").*\\.snvs\\.ptato\\.filtered\\.vcf\\.gz$")
all_filtered_vcfs <- all_filtered_vcfs[!grepl(pattern_exclude, all_filtered_vcfs, ignore.case = TRUE)]
# MinimalVAF cut-off
MinimalVAF <- 0.15
# Loop over all samples and make a list
SBSs_raw <- list()
for (Sample in input_df_sub$Sample_name) {
message("→ processing ", Sample)
filtered_vcf_path   <- all_filtered_vcfs[grepl(Sample, all_filtered_vcfs, ignore.case = TRUE)][1]
print(filtered_vcf_path) # to check if the right VCF file was used
vcf <- readVcf(filtered_vcf_path)
# Read VAF
if (!"VAF" %in% names(geno(vcf)))
stop("`geno(vcf)$VAF` not present in ", basename(filtered_vcf_path))
vaf <- geno(vcf)$VAF
if (length(dim(vaf)) == 2L)
vaf <- vaf[, 1, drop = TRUE]
# Add FILTER logic
rr <- rowRanges(vcf)
mcols(rr)$Chromosome <- as.character(seqnames(rr))
mcols(rr)$VAF    <- vaf
mcols(rr)$FILTER <- ifelse(vaf >= MinimalVAF, "PASS", "FAIL_VAF")
SBSs_raw[[Sample]]  <- rr
}
# Only autosomal
auto_chrs <- as.character(1:22)
SBSs_raw_015_autosomal <-  lapply(SBSs_raw_015, function(gr) {
keep <- seqnames(gr) %in% auto_chrs
gr2  <- gr[keep]
keepSeqlevels(gr2, auto_chrs, pruning.mode = "coarse")
}
)
# Only autosomal
auto_chrs <- as.character(1:22)
SBSs_raw_015_autosomal <-  lapply(SBSs_raw, function(gr) {
keep <- seqnames(gr) %in% auto_chrs
gr2  <- gr[keep]
keepSeqlevels(gr2, auto_chrs, pruning.mode = "coarse")
}
)
View(SBSs_raw_015_autosomal)
lengths <- nchar(SBSs_raw_015_autosomal)
lengths <- nchar(SBSs_raw_015_autosomal)
SBSs_raw_015_autosomal
range_len <- width(SBSs_raw_015_autosomal)
length(SBSs_raw_015_autosomal$`PB08410-BLLN-BCELLP1B11`)
# Remove all variants that are UNCALLABLE and/or with a PTAprobs < PTAprobsCutoff
SBSs_PASS_015_autosomal <- lapply(SBSs_raw_015_autosomal, function(x) x[which(x$FILTER =="PASS"),])
SBSs_FAIL_VAF_015_autosomal <- lapply(SBSs_raw_015_autosomal, function(x) x[which(x$FILTER =="FAIL_VAF"),])
sapply(SBSs_raw_015_autosomal, length)
lengths_all <- sapply(SBSs_raw_015_autosomal, length)
lengths_all
lengths_df  <- data.frame(
sample = names(lengths_all),
length = as.numeric(lengths_all)
)
write.xlsx(lengths_df, "Data/SBSs_lengths_all_samples.xlsx", rowNames = FALSE)
