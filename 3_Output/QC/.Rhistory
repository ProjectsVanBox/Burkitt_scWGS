input_df <-  read_excel('~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/1_Input/Sample_overview.xlsx') #dataframe
input_df_sub <- input_df[,c('Sample_name','Mean_coverage','Callable_fraction','Lymphoma_type', "ResolveDNA_version", "CNV", "BAF")] #sub-selection
library(ggplot2)
library(tidyverse)
library(readxl)
library(patchwork)
library(RColorBrewer)
setwd("~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/QC/")
date <- format(Sys.Date(), "%Y%m%d")
source('~/hpc/pmc_vanboxtel/projects/CHemALL/2_Code/PTATO_Ageline_checks/GeneralFunctions.R')
source('~/hpc/pmc_vanboxtel/projects/CHemALL/2_Code/theme_CHemALL.R')
qc_colors <- c('grey', '#54BFB7', '#0A9086')
input_df <-  read_excel('~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/1_Input/Sample_overview.xlsx') #dataframe
input_df_sub <- input_df[,c('Sample_name','Mean_coverage','Callable_fraction','Lymphoma_type', "ResolveDNA_version", "CNV", "BAF")] #sub-selection
input_df_sc <- input_df_sub[input_df_sub$ResolveDNA_version %in% c("v1", "v2", "v2.0"), ] #single-cells only
model_df <- input_df_sc[!is.na(input_df_sc$Callable_fraction) & !is.na(input_df_sc$Mean_coverage),] #make sure no N/A in Callable loci and Mean coverage
model_df$Mean_coverage <- as.numeric(model_df$Mean_coverage) #make this numeric
ggplot(model_df, aes(x = Mean_coverage, y = Callable_fraction)) +
geom_point() +
ylim(c(0,1)) +
theme_CHemALL() +
labs(title = "Identification of low quality samples")
cf_cutoff <- 0.45 # decided based on histogram above
below_cf_cutoff <- subset(model_df, Callable_fraction < cf_cutoff)
model_df$CallableLociQuality <- 'Pass'
model_df[model_df$Sample_name %in% below_cf_cutoff$Sample_name,]$CallableLociQuality <- 'Fail'
ggplot() +
geom_histogram(data = model_df, aes(x = Callable_fraction, fill = CallableLociQuality),
binwidth = 0.06)+
geom_vline(xintercept = 0.45) +
theme_CHemALL() +
scale_fill_manual(values = qc_colors[c(1,3)]) +
ggtitle('Callable loci distribution')
model_df_sub <- subset(model_df, Callable_fraction >= 0.45) # remove samples with lower than 40% callable genomes
low_call_frac_df <- subset(model_df, Callable_fraction < 0.45)
L_start <- max(model_df_sub$Callable_fraction)
k_start <- 0.1
x0_start <- mean(model_df_sub$Mean_coverage)
nls_logistic <- nls(Callable_fraction ~ L / (1 + exp(-k * (Mean_coverage - x0))),
data = model_df_sub,
start = list(L = L_start, k = k_start, x0 = x0_start))
model_df_sub$predicted_logistic <- predict(nls_logistic)
ggplot(model_df_sub, aes(x = Mean_coverage, y = Callable_fraction)) +
geom_point(color = "#54BFB7") +
scale_y_continuous(limits = c(0.40, 1)) +
geom_line(aes(y = predicted_logistic), color = "#000000", size = 1) +
labs(title = "Logistic Fit to CallableFraction vs MeanCoverage")
model_df_sub$residual <- model_df_sub$Callable_fraction - model_df_sub$predicted_logistic
cutoff <- -0.05 # decided based on histogram below
below_curve <- subset(model_df_sub, residual < cutoff)
model_df_sub$MappingQuality <- 'Pass'
model_df_sub[model_df_sub$Sample_name %in% below_curve$Sample_name,]$MappingQuality <- 'Fail'
ggplot() +
geom_histogram(data = model_df_sub, aes(x = residual, fill = MappingQuality),
binwidth = 0.02)+
geom_vline(xintercept = cutoff) +
theme_CHemALL() +
scale_fill_manual(values = qc_colors[c(1,3)]) +
ggtitle('Residual from predicted callable genome fraction')
below_curve$Sample_name
write.csv(below_curve, file = "Data/below_curve_samples.csv", row.names = F)
write.csv(low_call_frac_df , file = "Data/low_callable_loci.csv")
model_df_plot <- model_df_sub[ !(is.na(model_df_sub$BAF)),]
model_df_plot$CNV <- factor(model_df_plot$CNV, levels = c('to do','Bad','Intermediate','Good'))
model_df_plot$BAF <- factor(model_df_plot$BAF, levels = c('to do','Bad','Intermediate','Good'))
bad_baf_df <- subset(input_df, BAF == "Bad")
View(bad_baf_df)
setdiff(bad_baf_df$Sample_name, below_curve$Sample_name)
################################################################################
# Manuscript: Clonal Evolution of Paediatric Burkitt Lymphoma Through Time and Space
# Description: Script to look at callable loci and mean coverage of single cell WGS samples (QC step 1)
# Author: Alexander Steemers
# Date: July 2025
################################################################################
# Load libraries
library(ggplot2)
library(tidyverse)
library(readxl)
library(patchwork)
library(RColorBrewer)
# Set filepath
setwd("~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/QC/")
# Set date
date <- format(Sys.Date(), "%Y%m%d")
# Load plotting functions and color palette
source('~/hpc/pmc_vanboxtel/projects/CHemALL/2_Code/PTATO_Ageline_checks/GeneralFunctions.R')
source('~/hpc/pmc_vanboxtel/projects/CHemALL/2_Code/theme_CHemALL.R')
qc_colors <- c('grey', '#54BFB7', '#0A9086')
# Load metadata of single cell samples
input_df <-  read_excel('~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/1_Input/Sample_overview.xlsx') #dataframe
input_df_sub <- input_df[,c('Sample_name','Mean_coverage','Callable_fraction','Lymphoma_type', "ResolveDNA_version", "CNV", "BAF")] #sub-selection
input_df_sc <- input_df_sub[input_df_sub$ResolveDNA_version %in% c("v1", "v2", "v2.0"), ] #single-cells only
model_df <- input_df_sc[!is.na(input_df_sc$Callable_fraction) & !is.na(input_df_sc$Mean_coverage),] #make sure no N/A in Callable loci and Mean coverage
model_df$Mean_coverage <- as.numeric(model_df$Mean_coverage) #make this numeric
# Decide what cutoff to use for callable loci fraction
ggplot(model_df, aes(x = Mean_coverage, y = Callable_fraction)) +
geom_point() +
ylim(c(0,1)) +
theme_CHemALL() +
labs(title = "Identification of low quality samples")
ggplot() +
geom_histogram(data = model_df, aes(x = Callable_fraction),
binwidth = 0.06)+
geom_vline(xintercept = 0.45) +
theme_CHemALL() +
scale_fill_manual(values = qc_colors[c(1,3)]) +
ggtitle('Callable loci distribution')
cf_cutoff <- 0.45 # decided based on histogram above
below_cf_cutoff <- subset(model_df, Callable_fraction < cf_cutoff)
model_df$CallableLociQuality <- 'Pass'
model_df[model_df$Sample_name %in% below_cf_cutoff$Sample_name,]$CallableLociQuality <- 'Fail'
# Plot histogram
ggplot() +
geom_histogram(data = model_df, aes(x = Callable_fraction, fill = CallableLociQuality),
binwidth = 0.06)+
geom_vline(xintercept = 0.45) +
theme_CHemALL() +
scale_fill_manual(values = qc_colors[c(1,3)]) +
ggtitle('Callable loci distribution')
ggsave(paste0("Figures/callable_loci_histogram_allsamples_", date, ".pdf"), width = 5, height = 3)
# Remove samples with lower than 40% callable genomes
model_df_sub <- subset(model_df, Callable_fraction >= 0.45) # remove samples with lower than 40% callable genomes
# Samples which are initially filtered out due to low callable fraction (dataframe to export later)
low_call_frac_df <- subset(model_df, Callable_fraction < 0.45)
# Now plot logistic curve for mean coverage vs callable loci fraction
# Manual predicted values, define start values here
L_start <- max(model_df_sub$Callable_fraction)
k_start <- 0.1
x0_start <- mean(model_df_sub$Mean_coverage)
# Fit logistic model
nls_logistic <- nls(Callable_fraction ~ L / (1 + exp(-k * (Mean_coverage - x0))),
data = model_df_sub,
start = list(L = L_start, k = k_start, x0 = x0_start))
# Add predictions
model_df_sub$predicted_logistic <- predict(nls_logistic)
# Plot logistic curve
ggplot(model_df_sub, aes(x = Mean_coverage, y = Callable_fraction)) +
geom_point(color = "#54BFB7") +
scale_y_continuous(limits = c(0.40, 1)) +
geom_line(aes(y = predicted_logistic), color = "#000000", size = 1) +
labs(title = "Logistic Fit to CallableFraction vs MeanCoverage")
# Calculate residuals to identify outliers
model_df_sub$residual <- model_df_sub$Callable_fraction - model_df_sub$predicted_logistic
cutoff <- -0.05 # decided based on histogram below
below_curve <- subset(model_df_sub, residual < cutoff)
model_df_sub$MappingQuality <- 'Pass'
model_df_sub[model_df_sub$Sample_name %in% below_curve$Sample_name,]$MappingQuality <- 'Fail'
# Plot residuals in histogram and set cutoff for low quality samples
ggplot() +
geom_histogram(data = model_df_sub, aes(x = residual, fill = MappingQuality),
binwidth = 0.02)+
geom_vline(xintercept = cutoff) +
theme_CHemALL() +
scale_fill_manual(values = qc_colors[c(1,3)]) +
ggtitle('Residual from predicted callable genome fraction')
ggsave(paste0("Figures/residual_histogram_allsamples_", date, ".pdf"), width = 5, height = 3)
# Plot original relationship, but now with mappping quality filter
ggplot(model_df_sub, aes(x = Mean_coverage, y = Callable_fraction)) +
theme_CHemALL() +
geom_line(aes(y = predicted_logistic), color = qc_colors[2], linewidth = 1) +
geom_point(aes(color = MappingQuality), size = 2) +
scale_color_manual(values = qc_colors[c(1,3)]) +
scale_shape_manual(values = c(0, 1, 2, 3, 4, 5, 6, 7))+
labs(title = "Identification of low quality samples")
ggsave(paste0("Figures/correlation_plot_allsamples_", date, ".pdf"), width = 5, height = 3)
# Print outlier samples
below_curve$Sample_name
# Export samples that did not pass initial QC
write.csv(below_curve, file = "Data/below_curve_samples.csv", row.names = F)
write.csv(low_call_frac_df , file = "Data/low_callable_loci.csv")
# Side analysis
# Plot category CNV and BAFplot vs residual
model_df_plot <- model_df_sub[ !(is.na(model_df_sub$BAF)),]
model_df_plot$CNV <- factor(model_df_plot$CNV, levels = c('to do','Bad','Intermediate','Good'))
model_df_plot$BAF <- factor(model_df_plot$BAF, levels = c('to do','Bad','Intermediate','Good'))
p1 <- ggplot(data = model_df_plot[model_df_plot$CNV != 'to do',], aes(x = CNV, y = residual, fill = CNV)) +
geom_violin() + scale_fill_manual(values = qc_colors) + theme_CHemALL() +
geom_jitter(width = 0.2, size = 1, alpha = 0.7) +
geom_hline(yintercept = cutoff, linetype = "solid", color = "black") +
ggtitle('Residual from predicted callable genome fraction')
p2 <- ggplot(data = model_df_plot[model_df_plot$BAF != 'to do',], aes(x = BAF, y = residual, fill = BAF)) +
geom_violin() + scale_fill_manual(values = qc_colors) + theme_CHemALL() +
geom_jitter(width = 0.2, size = 1, alpha = 0.7) +
geom_hline(yintercept = cutoff, linetype = "solid", color = "black") +
ggtitle('Residual from predicted callable genome fraction')
p1 + p2
ggsave(paste0("Figures/residual_density_perCNV_BAF_group_", date, ".pdf"), width = 7, height = 3)
p3 <- ggplot(data = model_df_plot[model_df_plot$BAF != 'to do',], aes(x = BAF, y = Callable_fraction, fill = BAF)) +
geom_violin() + scale_fill_manual(values = qc_colors) + theme_CHemALL() +
geom_jitter(width = 0.2, size = 1, alpha = 0.7)
p4 <- ggplot(data = model_df_plot[model_df_plot$BAF != 'to do',], aes(x = BAF, y = Mean_coverage, fill = BAF)) +
geom_violin() + scale_fill_manual(values = qc_colors) + theme_CHemALL() +
geom_jitter(width = 0.2, size = 1, alpha = 0.7)
p3 + p4
# Intersect between bad BAF and low callable samples
bad_baf_df <- subset(input_df, BAF == "Bad")
intersect(bad_baf_df$Sample_name, below_curve$Sample_name)
setdiff(bad_baf_df$Sample_name, below_curve$Sample_name)
low_q_samples <- union(bad_baf_df$Sample_name, below_curve$Sample_name)
low_q_samples_df <- subset(model_df_sub, Sample_name %in% low_q_samples)
other_filters <- unique(c(below_curve$Sample_name, low_call_frac_df$Sample_name))
unique_to_bad_baf <- setdiff(bad_baf_df$Sample_name, other_filters)
unique_to_bad_baf
unique_to_bad_baf
################################################################################
# Manuscript: Clonal Evolution of Paediatric Burkitt Lymphoma Through Time and Space
# Description: Script to look at VAF distribution of single cell WGS samples (QC step 2)
# Author: Alexander Steemers
# Date: July 2025
################################################################################
# Laod libraries and functions
library(tibble)
library(dplyr)
library(tidyr)
library(ggplot2)
library(reshape2)
library(VariantAnnotation)
library(readxl)
library(ggpubr)
source('~/hpc/pmc_vanboxtel/projects/CHemALL/2_Code/PTATO/GeneralFunctions.R')
source('~/hpc/pmc_vanboxtel/projects/CHemALL/2_Code/theme_CHemALL.R')
# Set filepath
setwd("~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/QC")
# Load autosomal PASS variants above 0.15 VAF
SBSs_PASS <- readRDS(file = "~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/MutLoad/Data/autosomal_PASS_variants_VAF015.RDS")
# load metadata info
input_df <-  read_excel('~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/1_Input/Sample_overview.xlsx')
colnames(input_df)
input_df_sub <- input_df[,c('Sample_name','Mean_coverage' ,'Novogene_ID','Callable_fraction','Lymphoma_type', "ResolveDNA_version", "CNV", "BAF")]
input_df_sc <- input_df_sub[input_df_sub$ResolveDNA_version %in% c("v1", "v2", "v2.0"), ]
below_curve_df <-  read.csv("~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/QC/Data/below_curve_samples.csv")
low_call_frac_df <-  read.csv("~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/QC/Data/low_callable_loci.csv")
bad_baf_df <- read.csv("~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/QC/Data/bad_baf_samples.csv")
# Generate initial blacklist sample (based on QC step 1) and filter those out
blacklist_samples <- unique(c(below_curve_df$Sample, low_call_frac_df$Sample_name))
input_df_sc_filtered <- input_df_sc %>%
filter(!Sample_name %in% blacklist_samples)
# Plot TVD for all single cell mutations
# NB: variants underwent the following selection: SMuRF --> PTATO --> autosomal --> VAF >= 0.15
vafCheck <- SBSs_PASS[names(SBSs_PASS) %in% input_df_sc_filtered$Sample_name]
# Convert granges to list of dataframes
empty_df <- list()
for (Sample in names(vafCheck)){
vafCheck[[Sample]]$samplename <- Sample
print(head(data.frame(vafCheck[[Sample]])))
empty_df[[Sample]] <- data.frame(vafCheck[[Sample]])
}
plot_df <- bind_rows(empty_df, .id = "column_label")
plot_df1 <- merge(plot_df, input_df_sc_filtered[,c('Sample_name','Novogene_ID')], by.x = 'samplename',by.y = 'Sample_name')
# Determine cutoff using MAD outlier detection
# Parameters
num_bins <- 10
epsilon <- 1e-6  # to avoid zero-probability issues
# Decide here if using filtered data (coverage quality) or unfiltered data (all samples) --> I used filtered data
input_df_vafs <- plot_df1 # choose here
input_df_vafs <- input_df_vafs %>%
mutate(VAF = as.numeric(VAF))
# 1. Bin VAFs into histogram for each sample
binned_df <- input_df_vafs %>%
mutate(bin = cut(VAF, breaks = seq(0, 1, length.out = num_bins + 1), include.lowest = TRUE)) %>%
group_by(samplename, bin) %>%
summarise(count = n(), .groups = "drop") %>%
group_by(samplename) %>%
mutate(prob = (count + epsilon) / sum(count + epsilon)) %>%  # normalize
ungroup()
# 2. Pivot to wide format: one row per sample
wide_probs <- binned_df %>%
dplyr::select(samplename, bin, prob) %>%
pivot_wider(names_from = bin, values_from = prob, values_fill = list(prob = epsilon)) %>%
column_to_rownames("samplename")
# 3. Compute reference distribution (e.g., median across samples)
ref_dist <- apply(wide_probs, 2, median)
# 4. Compute TVD for each sample
tvd <- function(p, q) {
0.5 * sum(abs(p - q))
}
tvd_values <- apply(wide_probs, 1, function(p) tvd(p, ref_dist))
# 5. Output: samples ranked by TVD
tvd_df <- data.frame(samplename = names(tvd_values), TVD = tvd_values) %>%
arrange(desc(TVD))
# 6. Plot TVD scores
mad_val <- mad(tvd_df$TVD)
median_val <- median(tvd_df$TVD)
tvd_df <- tvd_df %>%
mutate(Flagged = TVD > (median_val + 3 * mad_val)) # https://www.sciencedirect.com/science/article/pii/S0022103113000668?via%3Dihub
# Plot TVD of VAF distributions
ggplot(tvd_df, aes(x = TVD, y = reorder(samplename, TVD),
fill = Flagged)) +
geom_bar(stat = "identity") +
coord_flip() +
labs(title = "Total Variation Distance of VAF Distributions",
x = "samplename", y = "TVD") +
scale_fill_manual(values = c('#54BFB7','grey')) + theme_CHemALL() +
theme(text =  element_text(size =  7, color = 'black'),
axis.text = element_text(size = 2, colour = "black")) +
ggTextAxisRotate()
ggsave('Figures/TVD_ranked_flagged_3_mad.pdf', width = 10, height = 3)
# Annotate the other plot with this
plot_df3b <- merge(input_df_vafs, tvd_df)
# Remove flagged with higher than median VAF
median(plot_df3b$VAF)
median_df <- plot_df3b %>% group_by(samplename) %>% summarise(med = median(VAF))
plot_df3b[plot_df3b$samplename %in% median_df[median_df$med > median(plot_df3b$VAF),]$samplename, 'Flagged'] <- FALSE
# Rename that column
plot_df3b$VAFfilter <- 'Pass'
plot_df3b[plot_df3b$Flagged,]$VAFfilter <- 'Fail'
# Split the dataframe into a list by Novogene_ID
plot_list <- split(plot_df3b, plot_df3b$Novogene_ID)
# Create one ggplot per Novogene_ID
plot_list <- lapply(names(plot_list), function(id) {
ggplot(data = plot_list[[id]],
aes(x = samplename,
y = VAF,
fill = VAFfilter)) +
geom_violin(draw_quantiles = c(0.25, 0.5, 0.75), alpha = 0.8) +
ggtitle(paste('VAF distribution -', id)) +
scale_fill_manual(values = c('Fail' = 'grey', 'Pass' = '#54BFB7')) +
theme_CHemALL() +
ggTextAxisRotate() +
theme(text = element_text(size = 7, color = 'black'),
axis.text = element_text(size = 4, colour = "black"))
})
names(plot_list) <- names(split(plot_df3b, plot_df3b$Novogene_ID))  # optional, to keep names
plot_list[[1]]
plot_list[[2]]
plot_list[[3]]
plot_list[[4]]
plot_list[[5]]
plot_list[[6]]
for (i in seq_along(plot_list)) {
plot_name <- names(plot_list)[i]
ggsave(filename = paste0("Figures/VAF_violinplot_TVD_flagged_", plot_name, ".pdf"),
plot = plot_list[[i]],
width = 6, height = 4, units = "in")
}
# Export these samples that failed VAF QC step 2
fail_df_pta <- unique(plot_df3b[plot_df3b$VAFfilter == 'Fail', c('samplename','Novogene_ID')])
write_csv(fail_df_pta, '../QC/Data/PTA_samples_failVAFcheck.txt')
other_filters <- unique(c(below_curve$Sample_name, low_call_frac_df$Sample_name, fail_df_pta$Sample_name))
unique_to_bad_baf <- setdiff(bad_baf_df$Sample_name, other_filters)
unique_to_bad_baf
################################################################################
# Manuscript: Clonal Evolution of Paediatric Burkitt Lymphoma Through Time and Space
# Description: Script to look at callable loci and mean coverage of single cell WGS samples (QC step 1)
# Author: Alexander Steemers
# Date: July 2025
################################################################################
# Load libraries
library(ggplot2)
library(tidyverse)
library(readxl)
library(patchwork)
library(RColorBrewer)
# Set filepath
setwd("~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/3_Output/QC/")
# Set date
date <- format(Sys.Date(), "%Y%m%d")
# Load plotting functions and color palette
source('~/hpc/pmc_vanboxtel/projects/CHemALL/2_Code/PTATO_Ageline_checks/GeneralFunctions.R')
source('~/hpc/pmc_vanboxtel/projects/CHemALL/2_Code/theme_CHemALL.R')
qc_colors <- c('grey', '#54BFB7', '#0A9086')
# Load metadata of single cell samples
input_df <-  read_excel('~/surfdrive/Shared/pmc_vanboxtel/projects/Burkitt_github/1_Input/Sample_overview.xlsx') #dataframe
input_df_sub <- input_df[,c('Sample_name','Mean_coverage','Callable_fraction','Lymphoma_type', "ResolveDNA_version", "CNV", "BAF")] #sub-selection
input_df_sc <- input_df_sub[input_df_sub$ResolveDNA_version %in% c("v1", "v2", "v2.0"), ] #single-cells only
model_df <- input_df_sc[!is.na(input_df_sc$Callable_fraction) & !is.na(input_df_sc$Mean_coverage),] #make sure no N/A in Callable loci and Mean coverage
model_df$Mean_coverage <- as.numeric(model_df$Mean_coverage) #make this numeric
# Decide what cutoff to use for callable loci fraction
ggplot(model_df, aes(x = Mean_coverage, y = Callable_fraction)) +
geom_point() +
ylim(c(0,1)) +
theme_CHemALL() +
labs(title = "Identification of low quality samples")
ggplot() +
geom_histogram(data = model_df, aes(x = Callable_fraction),
binwidth = 0.06)+
geom_vline(xintercept = 0.45) +
theme_CHemALL() +
scale_fill_manual(values = qc_colors[c(1,3)]) +
ggtitle('Callable loci distribution')
cf_cutoff <- 0.45 # decided based on histogram above
below_cf_cutoff <- subset(model_df, Callable_fraction < cf_cutoff)
model_df$CallableLociQuality <- 'Pass'
model_df[model_df$Sample_name %in% below_cf_cutoff$Sample_name,]$CallableLociQuality <- 'Fail'
# Plot histogram
ggplot() +
geom_histogram(data = model_df, aes(x = Callable_fraction, fill = CallableLociQuality),
binwidth = 0.06)+
geom_vline(xintercept = 0.45) +
theme_CHemALL() +
scale_fill_manual(values = qc_colors[c(1,3)]) +
ggtitle('Callable loci distribution')
ggsave(paste0("Figures/callable_loci_histogram_allsamples_", date, ".pdf"), width = 5, height = 3)
# Remove samples with lower than 40% callable genomes
model_df_sub <- subset(model_df, Callable_fraction >= 0.45) # remove samples with lower than 40% callable genomes
# Samples which are initially filtered out due to low callable fraction (dataframe to export later)
low_call_frac_df <- subset(model_df, Callable_fraction < 0.45)
# Now plot logistic curve for mean coverage vs callable loci fraction
# Manual predicted values, define start values here
L_start <- max(model_df_sub$Callable_fraction)
k_start <- 0.1
x0_start <- mean(model_df_sub$Mean_coverage)
# Fit logistic model
nls_logistic <- nls(Callable_fraction ~ L / (1 + exp(-k * (Mean_coverage - x0))),
data = model_df_sub,
start = list(L = L_start, k = k_start, x0 = x0_start))
# Add predictions
model_df_sub$predicted_logistic <- predict(nls_logistic)
# Plot logistic curve
ggplot(model_df_sub, aes(x = Mean_coverage, y = Callable_fraction)) +
geom_point(color = "#54BFB7") +
scale_y_continuous(limits = c(0.40, 1)) +
geom_line(aes(y = predicted_logistic), color = "#000000", size = 1) +
labs(title = "Logistic Fit to CallableFraction vs MeanCoverage")
# Calculate residuals to identify outliers
model_df_sub$residual <- model_df_sub$Callable_fraction - model_df_sub$predicted_logistic
cutoff <- -0.05 # decided based on histogram below
below_curve <- subset(model_df_sub, residual < cutoff)
model_df_sub$MappingQuality <- 'Pass'
model_df_sub[model_df_sub$Sample_name %in% below_curve$Sample_name,]$MappingQuality <- 'Fail'
# Plot residuals in histogram and set cutoff for low quality samples
ggplot() +
geom_histogram(data = model_df_sub, aes(x = residual, fill = MappingQuality),
binwidth = 0.02)+
geom_vline(xintercept = cutoff) +
theme_CHemALL() +
scale_fill_manual(values = qc_colors[c(1,3)]) +
ggtitle('Residual from predicted callable genome fraction')
ggsave(paste0("Figures/residual_histogram_allsamples_", date, ".pdf"), width = 5, height = 3)
# Plot original relationship, but now with mappping quality filter
ggplot(model_df_sub, aes(x = Mean_coverage, y = Callable_fraction)) +
theme_CHemALL() +
geom_line(aes(y = predicted_logistic), color = qc_colors[2], linewidth = 1) +
geom_point(aes(color = MappingQuality), size = 2) +
scale_color_manual(values = qc_colors[c(1,3)]) +
scale_shape_manual(values = c(0, 1, 2, 3, 4, 5, 6, 7))+
labs(title = "Identification of low quality samples")
ggsave(paste0("Figures/correlation_plot_allsamples_", date, ".pdf"), width = 5, height = 3)
# Print outlier samples
below_curve$Sample_name
# Export samples that did not pass initial QC
write.csv(below_curve, file = "Data/below_curve_samples.csv", row.names = F)
write.csv(low_call_frac_df , file = "Data/low_callable_loci.csv")
# Side analysis
# Plot category CNV and BAFplot vs residual
model_df_plot <- model_df_sub[ !(is.na(model_df_sub$BAF)),]
model_df_plot$CNV <- factor(model_df_plot$CNV, levels = c('to do','Bad','Intermediate','Good'))
model_df_plot$BAF <- factor(model_df_plot$BAF, levels = c('to do','Bad','Intermediate','Good'))
p1 <- ggplot(data = model_df_plot[model_df_plot$CNV != 'to do',], aes(x = CNV, y = residual, fill = CNV)) +
geom_violin() + scale_fill_manual(values = qc_colors) + theme_CHemALL() +
geom_jitter(width = 0.2, size = 1, alpha = 0.7) +
geom_hline(yintercept = cutoff, linetype = "solid", color = "black") +
ggtitle('Residual from predicted callable genome fraction')
p2 <- ggplot(data = model_df_plot[model_df_plot$BAF != 'to do',], aes(x = BAF, y = residual, fill = BAF)) +
geom_violin() + scale_fill_manual(values = qc_colors) + theme_CHemALL() +
geom_jitter(width = 0.2, size = 1, alpha = 0.7) +
geom_hline(yintercept = cutoff, linetype = "solid", color = "black") +
ggtitle('Residual from predicted callable genome fraction')
p1 + p2
ggsave(paste0("Figures/residual_density_perCNV_BAF_group_", date, ".pdf"), width = 7, height = 3)
p3 <- ggplot(data = model_df_plot[model_df_plot$BAF != 'to do',], aes(x = BAF, y = Callable_fraction, fill = BAF)) +
geom_violin() + scale_fill_manual(values = qc_colors) + theme_CHemALL() +
geom_jitter(width = 0.2, size = 1, alpha = 0.7)
p4 <- ggplot(data = model_df_plot[model_df_plot$BAF != 'to do',], aes(x = BAF, y = Mean_coverage, fill = BAF)) +
geom_violin() + scale_fill_manual(values = qc_colors) + theme_CHemALL() +
geom_jitter(width = 0.2, size = 1, alpha = 0.7)
p3 + p4
# Intersect between bad BAF and low callable samples
bad_baf_df <- subset(input_df, BAF == "Bad")
intersect(bad_baf_df$Sample_name, below_curve$Sample_name)
setdiff(bad_baf_df$Sample_name, below_curve$Sample_name)
low_q_samples <- union(bad_baf_df$Sample_name, below_curve$Sample_name)
low_q_samples_df <- subset(model_df_sub, Sample_name %in% low_q_samples)
other_filters <- unique(c(below_curve$Sample_name, low_call_frac_df$Sample_name))
unique_to_bad_baf <- setdiff(bad_baf_df$Sample_name, other_filters)
unique_to_bad_baf
13+37+9
59+25
332-84
248/332
other_filters
unique_to_bad_baf
fail_df_pta
fail_df_pta$samplename
